#!/usr/bin/env node

/**
 * Generate tsconfig.json files for every packages including root.
 * Define paths and references.
 */

import path from 'path';
import fs from 'fs';
import glob from 'glob';
import shx from 'shelljs';
import { createRequire } from 'module';
const require = createRequire(import.meta.url);

/**
 * package.json partial type.
 * @typedef {Object} Pkg
 * @property {string|undefined} name
 * @property {string[]|undefined} workspaces
 * @property {Object<string,string>|undefined} dependencies
 * @property {Object<string,string>|undefined} devDependencies
 * @property {Object<string,string>|undefined} peerDependencies
 */

/**
 * @param {I[]} arr
 * @template I
 */
const uniqueArray = (arr) => Array.from(new Set(arr));

const rootPath = process.env.PROJECT_CWD;

/**
 * @type {Pkg}
 */
const { workspaces = [] } = require(path.resolve(rootPath, 'package.json'));

const tsPkgs = workspaces
  .flatMap((pattern) => glob.sync(pattern))
  .map((pt) => {
    /**
     * @type {Pkg}
     */
    const pkg = require(path.resolve(pt, 'package.json'));

    const everyDeps = Object.assign(
      {},
      pkg.dependencies,
      pkg.devDependencies,
      pkg.peerDependencies
    );

    const deps = uniqueArray(
      Object.keys(everyDeps).filter((dep) =>
        everyDeps[dep].startsWith('workspace:')
      )
    );

    return {
      name: pkg.name,
      dir: path.resolve(pt),
      relative: `./${path.join(pt)}`,
      deps,
    };
  });

// generate tsconfig.json for each package
tsPkgs.forEach(({ name, dir, deps }) => {
  // @ts-ignore
  const isApp = name.startsWith('api');

  const references = deps.map((dep) => {
    const tsPkg = tsPkgs.find((tp) => tp.name === dep);

    // @ts-ignore
    return { path: path.relative(dir, tsPkg.dir) };
  });

  const paths = deps.reduce(
    /**
     * @param {Record<string, string[]>} map
     */
    (map, dep) => {
      const tsPkg = tsPkgs.find((tp) => tp.name === dep);

      if (tsPkg) {
        map[`${tsPkg.name}/*`] = [`${path.relative(dir, tsPkg.dir)}/src/*`];
      }

      return map;
    },
    {
      [`${name}/*`]: [isApp ? './*' : './src/*'],
    }
  );

  const tsConfigPath = path.resolve(dir, 'tsconfig.json');

  /**
   * @type {{
   *   compilerOptions?: Object;
   *   include?: string[];
   * }}
   */
  const existingTsConfig = fs.existsSync(tsConfigPath)
    ? require(tsConfigPath)
    : {};

  const includeExts = ['ts', 'tsx', 'js', 'json'].map(
    (ext) => (isApp ? './**/*.' : './src/**/*.') + ext
  );

  fs.writeFileSync(
    tsConfigPath,
    JSON.stringify(
      {
        ...existingTsConfig,
        extends: '../../tsconfig.base.json',
        compilerOptions: {
          ...existingTsConfig.compilerOptions,
          rootDir: isApp ? undefined : './src',
          outDir: './node_modules/.cache/dist',
          tsBuildInfoFile: './node_modules/.cache/.tsbuildinfo',
          paths,
        },
        include: uniqueArray([
          ...includeExts,
          ...(existingTsConfig.include || []),
        ]),
        references,
      },
      null,
      2
    )
  );
});

// generate root tsconfig.json
fs.writeFileSync(
  path.resolve(rootPath, `tsconfig.json`),
  `/* This file is automatically generated by scripts/generators/tsconfig.js */\n${JSON.stringify(
    {
      extends: './tsconfig.base.json',
      compilerOptions: {
        noEmit: true,
        tsBuildInfoFile: './node_modules/.cache/.tsbuildinfo',
      },
      include: ['*.js', '*.json', 'scripts/**/*.js', 'config/**/*.js'],
      references: tsPkgs.map(({ dir }) => ({
        path: path.relative(rootPath, dir),
      })),
    },
    null,
    2
  )}`
);

// format every tsconfig.json files
shx.exec(`yarn prettier -w ${rootPath}/**/tsconfig.json`);
